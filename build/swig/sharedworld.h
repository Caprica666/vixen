namespace Vixen
{
/*!
 * @class SharedWorld
 * Maintains an external event queue to share the Vixen 3D world
 * with an external application environment. The SWIG wrappers
 * export this class to C# to all .NET applications which use
 * the C# wrappers generated by SWIG to handle Vixen events.
 *
 * @see VisualApp World3D Messenger.Observe Canvas3D
 */
class SharedWorld : public World3D
{
	protected:
		Core::Semaphore	m_EventPending;	// signals events waiting
		Core::List		m_EventQueue;	// Vixen -> C# event queue
		Event*			m_LastEvent;	// last event added to queue
		bool			m_Stopped;		// true if event processing stopped

	public:
		SharedWorld() : World3D(), m_EventPending(1000000)
		{
			m_Stopped = false;
			m_EventQueue.Next = NULL;
			m_LastEvent = (Event*) &m_EventQueue;
		}

		static	SharedWorld*	Get()	{ return (SharedWorld*) World3D::Get(); }

		void	SetMediaDir(const TCHAR* dir)
		{
			FileLoader*	loader = GetLoader();
			if (loader)
				loader->SetDirectory(dir);
		}

		const TCHAR* GetMediaDir()
		{
			FileLoader*	loader = GetLoader();
			if (loader)
				return loader->GetDirectory();
			return NULL;
		}


		/*!
		 * Called when the world is exiting, shuts down event queue
		 */
		virtual void OnExit()
		{
			StopEvents();
#ifndef VIXEN_LITE
			Physics::Shutdown(SCENE_UIThread);
#endif
			World3D::OnExit();
		}

		virtual void OnThreadExit(int threadtype)
		{
#ifndef VIXEN_LITE
			Physics::Shutdown(threadtype);
#endif
		}

		/*!
		 * Shut down the shared event queue, delete all events.
		 * The event pending signal is raised to allow the
		 * consumer application to exit.
		 */
		void StopEvents()
		{
			if (m_Stopped)
				return;
			Lock();
			m_EventQueue.Empty();
			m_LastEvent = NULL;
			m_Stopped = true;
			Unlock();
			m_EventPending.Release();
		}

		/*!
		 * Requests another event from the shared queue.
		 * This function will block until an event is available so
		 * do not call it from a main thread!
		 * It will not return until a Vixen event occurs or
		 * event processing is shut down.
		 */
		Event* NextEvent()
		{
			while (!m_Stopped)
			{
				Lock();
				Event* ev = (Event*) m_EventQueue.Next;
				if (ev)
				{
					m_EventQueue.Next = ev->Next;
					if (ev == m_LastEvent)
						m_LastEvent = NULL;
					Unlock();
					return ev;
				}
				Unlock();
				m_EventPending.Wait();
			}
			return NULL;
		}

		/*!
		 * Observe a vixen event based on it's integer code.
		 * @param eventcode	Vixen event code of event to observe
		 * @param observer	pointer to Vixen object which should observe this event.
		 *					if NULL, this event will be observed by the SharedWorld.
		 * @param sender	pointer to Vixen source object which sent the event.
		 *					Only events from this source will be observed.
		 *					if NULL, events from all sources are considered.
		 *					
		 * Events observed by the SharedWorld are stored in an external
		 * queue so external applications may consume them. If you want more than one
		 * object to observe the event you have to make two calls to Observe.
		 *
		 * @see Vixen.Event NextEvent
		 */
		void Observe(int eventcode, SharedObj* observer = NULL, SharedObj* sender = NULL)
		{
			Messenger* mess = GetMessenger();

			if (observer == NULL)
				observer = this;
			if (mess != NULL)
			{
				mess->Observe(observer, eventcode, sender);
				return;
			}
			VX_ERROR_RETURN(("SharedWorld::Observe Messenger is NULL"));
		}

		void OnMouse(int xpos, int ypos, int flags, float time)
		{
			MouseEvent* ev = new MouseEvent();
			int buttons = 0;

			ev->Sender = this;
			ev->MousePos.x = (float) xpos;
			ev->MousePos.y = (float) ypos;
			ev->MouseFlags = flags;
			ev->Time = time;
			ev->Log();
		}

		/*!
		 * Suspend the currently displayed scene so that changes to the hierarchy can be made.
		 * You cannot safely add or remove anything from the scene graph or simulation tree
		 * unless you suspend display first.
		 */
		void SuspendScene()
		{
			Scene* scene = GetScene();
			if (scene)
				scene->Suspend();
		}
		
		/*!
		 * Resumes scene display after suspend.
		 */
		void ResumeScene()
		{
			Scene* scene = GetScene();
			if (scene)
				scene->Resume();
		}

		/*!
		 * Saves a Vixen object in a file in binary format.
		 * @param obj	Vixen object to save
		 * @param filename	name of file to save it in
		 *
		 * @returns true if successfully saved, else false
		 */
		bool SaveAsVix(SharedObj* obj, const TCHAR* filename)
		{
			FileMessenger	savefile;
			if (savefile.Open(filename, Messenger::OPEN_WRITE))
			{
				obj->Save(savefile, Messenger::OPEN_WRITE);
				savefile.Close();
				return true;
			}
			return false;
		}

	   /*!
		* Logs an error message to the error output stream.
		* By default, this is the console.
		* A terminating newline is added.
		*/
		static void LogError(const char* s)
		{
			if (STRLEN(s) < VX_MaxString)
				Core::ErrorPrint((char*) s);
			else
			{
				Core::String tmp(s, VX_MaxString - 4);
				s = tmp;
				Core::ErrorPrint((char*) s);
			}
		}

	   /*!
		* Prints a message to the error output stream.
		* By default, this is the console.
		* A terminating newline is NOT added.
		*/
		static void Trace(const char* s)
		{
			if (SharedWorld::Debug)
			{
				if (STRLEN(s) < VX_MaxString)
					Core::DebugPrint((char*) s);
				else
				{
					Core::String tmp(s, VX_MaxString - 4);
					s = tmp;
					Core::DebugPrint((char*) s);
				}
			}
		}

		static void SetDebugLevel(int debug)
		{
			if (debug > 0)
			{
				FileLoader::Debug = 1;
				Bitmap::Debug = 1;
				SharedWorld::Debug = 1;
			}
			if (debug > 1)
			{
				Event::Debug = 1;
				Messenger::Debug = 1;
				RayPicker::Debug = 1;
				Skeleton::Debug = 1;
			}
			if (debug > 2)
			{
				Messenger::Debug = 2;
				RayPicker::Debug = 2;
				Skeleton::Debug = 2;
			}
		}


	protected:
		virtual void Stop()
		{
			StopEvents();
			World3D::Stop();
		}

		/*!
		 * Vixen events observed by this Shared World are handled here.
		 * They are put in a shared queue.This is where events which
		 * have already been consumed are released.
		 */
		virtual bool OnEvent(Event* ev)
		{
			World3D::OnEvent(ev);
			switch (ev->Code)
			{
				default:				// filter out these
				return false;

				case Event::START:
				case Event::STOP:
				case Event::RESET:
				case Event::SCENE_CHANGE:
				case Event::LOAD_IMAGE:
				case Event::LOAD_SCENE:
				case Event::LOAD_TEXT:
				case Event::LOAD_DATA:
				case Event::ENTER:
				case Event::LEAVE:
				case Event::PICK:
				case Event::NOPICK:
				case Event::SELECT:
				case Event::DESELECT:
				case Event::ERROR:
				case Event::TRACK:
				case Event::COLLIDE:
				break;
			}
			if (m_Stopped)
				return true;
			VX_TRACE(Messenger::Debug || Event::Debug, ("SharedWorld::OnEvent %d %s", ev->Code, ev->GetName()));
			Event* e = MakeEvent(ev->Code);
			*e = *((Event*) ev);				// make a copy of the event	
			e->Next = NULL;
			Lock();								// lock the event queue
			if (m_LastEvent)
				m_LastEvent->Next = e;			// put new event at the end
			else
				m_EventQueue.Append(e);
			m_LastEvent = e;
			Unlock();							// unlock event queue
			m_EventPending.Release();			// signal consumer we have events
			return true;
		}
};

}	// end Vixen
