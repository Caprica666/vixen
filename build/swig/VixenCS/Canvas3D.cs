using System;
using System.Threading;
using System.Windows;
using System.Windows.Interop;
using System.Runtime.InteropServices;
using System.IO;


namespace Vixen
{
	/*!
	 * C# RoutedEventArgs from the Vixen 3D system.
	 * When the Vixen SharedWorld observes a Vixen event,
	 * it is converted to a Vixen.RoutedEvent so it can be handled
	 * with the C# event mechanism. The only event argument is
	 * the Vixen.Event object generated by the 3D environment.
	 */
	public class VixenEventArgs : RoutedEventArgs
	{
		public Event VixEvent { get; set; }

		public VixenEventArgs(Event ev, RoutedEvent re) : base(re) { VixEvent = ev; }
		~VixenEventArgs() { }
	};
	
	/*!
	 * A main window which hosts Vixen 3D content.
	 * This class handles routine of mouse and keyboard events
	 * as well as starting and stopping 3D processing.
	 */
	public class Canvas3D : HwndHost
	{
		[DllImport("user32.dll", SetLastError = true)]
		internal static extern bool DestroyWindow(IntPtr hWnd);

		[DllImport("user32.dll", EntryPoint = "CreateWindowEx", CharSet = CharSet.Unicode)]
		internal static extern IntPtr CreateWindowEx(int dwExStyle,
											string lpszClassName,
											string lpszWindowName,
											int style,
											int x, int y,
											int width, int height,
											IntPtr hwndParent,
											IntPtr hMenu,
											IntPtr hInst,
											[MarshalAs(UnmanagedType.AsAny)] object pvParam);
		private IntPtr _window = IntPtr.Zero;
		private Scene _scene = null;
		static public int Debug = 0;
		static public bool UsePhysics = false;
		static private SharedWorld _world = null;
		private bool _stopevents = false;

		/*!
		 * Returns an absolute path to a media file.
		 * @param filename	name of media file (may be absolute or relative).
		 *
		 * If the input pathname is absolute, it is simply returned.
		 * Otherwise, the media directory is prepended to
		 * make an absolute path.
		 * 
		 * @return absolute path of media file
		 * @see MediaDir
		 */
		public string GetMediaPath(System.String filename)
		{
			if (MediaDir == null)
				return filename;
			return Path.Combine(MediaDir, filename);
		}

		public System.String MediaDir
		{
			get { return base.GetValue(MediaDirProp) as System.String; }
			set { base.SetValue(MediaDirProp, value); }
		}

		public System.String ContentFile
		{
			get { return base.GetValue(ContentFileProp) as System.String; }
			set { base.SetValue(ContentFileProp, value); }
		}

		public static readonly DependencyProperty MediaDirProp = DependencyProperty.Register("MediaDir", typeof(System.String), typeof(Canvas3D));
		public static readonly DependencyProperty ContentFileProp = DependencyProperty.Register("ContentFile", typeof(System.String), typeof(Canvas3D));


		/*!
		  * The Vixen world containing the 3D scenes for this application.
		  * A world may have multiple windows with 3D scenes.
		  */
		public SharedWorld Viewer { get { return _world; } }

		/*!
		 * C# RoutedEvent from the Vixen 3D system.
		 * Events generated by the 3D world and observed by the C#
		 * application are converted to Vixen.RoutedEvent objects
		 * so they can be handled by the normal NET event mechanism.
		 * You can observe these events with SharedWorld.Observe and
		 * handle them by implementing a handler for VixenEvent.
		 *
		 * From a Canvas3D subclass, you just need to add a VixenEventHandler override
		 * to catch all the Vixen events.
		 * @see Messenger.Observe Vixen.EventArgs VixenEventHandler
		 */
		public static readonly RoutedEvent RoutedVixenEvent = EventManager.RegisterRoutedEvent("Vixen",
				RoutingStrategy.Bubble, typeof(VixenEventHandler), typeof(Canvas3D));

		/*!
		 * Hook to get Vixen events directed to this control.
		 * Subclass Canvas3D and add a handler for Vixen events like this:
		 * @code
		 * class MyControl : Canvas3D
		 * {
		 *      public MyControl() : base()
		 *      {
		 *          VixenEvent += MyControl_OnVixenEvent;
		 *      }
		 *      private void MyControl_OnEvent(Object sender, Vixen.EventArgs args)
		 *      {
		 *          Event ev = args.VixEvent;
		 *          Console.WriteLine("EVENT " + ev.GetName());
		 *      }
		 * }
		 * @endcode
		 */
		public delegate void VixenEventHandler(object sender, VixenEventArgs e);

		public event VixenEventHandler VixenEvent;

		public Canvas3D()
			: base()
		{
		}

		protected override HandleRef BuildWindowCore(HandleRef parentwin)
		{
			const int WS_CHILD = 0x40000000;
			const int WS_VISIBLE = 0x10000000;
			const int HOST_ID = 2;

			_window = CreateWindowEx(0, "mdiclient", "Vixen",
							WS_CHILD | WS_VISIBLE,
							0, 0,
							(int) ActualWidth, (int) ActualHeight,
							parentwin.Handle,
							(IntPtr) HOST_ID,
							IntPtr.Zero,
							0);
			return new HandleRef(this, _window);
		}

		protected override void DestroyWindowCore(HandleRef hwnd)
		{
			DestroyWindow(_window);
		}

		/*!
		 * Routes a mouse event from this window to Vixen.
		 * Any Vixen objects which observe Event.MOUSE will get these events.
		 * If DispatchMouseEvents is false, this functionality is disabled.
		 * @see DispatchMouseEvents
		 */
		protected override IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)
		{
			const int WM_LBUTTONDBLCLK = 0x203;
			const int WM_RBUTTONDBLCLK = 0x206;
			const int WM_MBUTTONDBLCLK = 0x209;
			const int WM_MOUSEMOVE = 0x0200;
			const int WM_LBUTTONDOWN = 0x0201;
			const int WM_LBUTTONUP = 0x0202;
			const int WM_RBUTTONDOWN = 0x0204;
			const int WM_RBUTTONUP = 0x0205;
			const int WM_MBUTTONDOWN = 0x0207;
			const int WM_MBUTTONUP = 0x0208;
			const int WM_MOVE = 0x0003;
			const int WM_SIZE = 0x0005;
			const int WM_DISPLAYCHANGE = 0x007E;
			const int WM_ERASEBKGND = 0x0014;

			int x, y;
			int buttons = (int) wParam & 0X1F;

			if ((_world == null) || !_world.IsRunning())
				return IntPtr.Zero;
			switch (msg)
			{
				case WM_ERASEBKGND:
				handled = true;
				return IntPtr.Zero;

				case WM_MOVE:
				case WM_SIZE:
				if (_scene == null)
				{
					_scene = _world.GetScene();
					if (_scene == null)
						return IntPtr.Zero;
				}
				_scene.Suspend();
				_scene.OnResize();
				_scene.Resume();
				handled = true;
				return IntPtr.Zero;
	
				case WM_LBUTTONDBLCLK:
				case WM_RBUTTONDBLCLK:
				case WM_MBUTTONDBLCLK:
				buttons |= MouseEvent.DOUBLE;
				break;

				case WM_RBUTTONDOWN:
				case WM_RBUTTONUP:
				case WM_LBUTTONDOWN:
				case WM_LBUTTONUP:
				case WM_MBUTTONDOWN:
				case WM_MBUTTONUP:
				case WM_MOUSEMOVE:
				break;

				default:
				handled = false;
				return IntPtr.Zero;
			}
			x = (int)((long)lParam & (long)0x0000ffff); // LOWORD = x
			y = (int)((long)lParam >> 16);              // HIWORD = y
			_world.OnMouse(x, y, buttons, 0.0f);
			OnMouse(x, y, buttons, 0);
			handled = true;
			return IntPtr.Zero;
		}


		/*!
		 * Establishes the intial Vixen Scene for this window.
		 * If a filename was provided on the command line, Vixen
		 * will assume it is a 3D content file and automatically load it.
		 * If you set World.DoAsyncLoad to false or if no filename is provided,
		 * this asynchronous content loading is disabled and MakeScene is called.
		 * The default implementation just returns null but you can
		 * override this function to make a custom scene.
		 */
		public virtual Scene MakeScene() { return null; }

		protected override void OnInitialized(System.EventArgs e)
		{
			base.OnInitialized(e);
			Loaded += OnLoad;
			Unloaded += OnClose;
			Dispatcher.ShutdownStarted += OnClose;
		}

		protected virtual void OnLoad(Object sender, System.EventArgs e)
		{
			RunVixen();
		}

		protected virtual void OnClose(Object sender, System.EventArgs e)
		{
			StopVixen();
		}

		/*!
		 * @param world Vixen 3D world
		 * Initializes the Vixen 3D environment for the given world.
		 * If you do not provide an initial world, one is created for you.
		 * This function does not start 3D display - RunVixen does that.
		 * The world can only be initialized once - subsequent calls do nothing.
		 *
		 * @return -> Vixen SharedWorld or null if initialization failed
		 */
		static public SharedWorld StartVixen(SharedWorld world)
		{
			_world = world;
			if (_world == null)
				_world = new Viewer3D();
			else if (_world.FileName != null)
			{
				string dir = Path.GetDirectoryName(_world.FileName);
				if ((dir != null) && (dir.Length > 0))
				{
					Directory.SetCurrentDirectory(dir);
					_world.SetMediaDir(dir);
				}
			}
			if ((_world == null) || !_world.OnInit())
			{
				SharedWorld.LogError("cannot initialize Vixen");
				return null;
			}
            GC.KeepAlive(_world);
			_world.MakeLock();
			if (UsePhysics)
				Physics.Startup();
			return _world;
		}

		/*!
		 * Start up Vixen 3D display and event processing.
		 * This function should not be called until the
		 * underlying Window has been created and the
		 * OS window handle is available. Vixen will display
		 * the 3D content in this window.
		 */
		public virtual bool RunVixen()
		{
			bool loadasync = World.DoAsyncLoad;

			if (_world == null)
			{
				SharedWorld.LogError("Vixen did not start");
				return false;
			}
			if (_window == null)
			{
				SharedWorld.LogError("Cannot get window handle for parent window");
				return false;
			}
			if (_world.IsRunning())
				return false;
			//world.SetDebugLevel(1);
			if (MediaDir != null)
				_world.SetMediaDir(MediaDir);
			if (ContentFile == null)
				loadasync = false;
			else if (loadasync)
				_world.FileName = GetMediaPath(ContentFile);
			_world.Run((long) _window);
			if (_world.IsRunning())
			{
				ThreadStart eventloop = new ThreadStart(EventLoop);
				Thread thread = new Thread(eventloop);

				_scene = SharedWorld.MainScene;
				thread.Start();
				if (!loadasync)
					try
					{
						Scene scene = MakeScene();
                        if (scene != null)
                        {
                            GC.KeepAlive(scene);
                            _world.SetScene(scene);
                        }
					}
					catch (Exception ex)
					{
						SharedWorld.LogError("exception making initial scene " + ex.Message);
					}
				return true;
			}
			return false;
		}

		/*!
		 * Shuts down 3D processing and releases all 3D resources.
		 * This routine is called automatically when the window closes.
		 */
		public virtual void StopVixen()
		{
			if (_world != null)
			{
				if (_scene != null)
					_scene.Window = 0;
				_world.StopEvents();
			}
		}

		/*!
		 * Override this function to handle initial scene loading
		 */
		protected virtual void OnSceneLoad(Scene scene, string sceneFile)
		{
		}

		/*!
		 * Override this function to handle Vixen events.
		 * If a Vixen event handler has been registered OnVixen will be called.
		 */
		protected virtual void OnVixen(VixenEventArgs e)
		{
			if (VixenEvent != null)
				VixenEvent(this, e);
		}

		/*!
		 * Override this function to handle mouse events routed to Vixen.
		 */
		protected virtual void OnMouse(float x, float y, int buttons, float t)
		{
		}


		/*!
		 * Events are moved from the Vixen SharedWorld to the C#
		 * application through a shared event queue. Events
		 * observed and handled by the Vixen SharedWorld object
		 * are put into a queue. The Canvas3D class maintains a separate
		 * thread which waits on this queue and converts any Vixen Events
		 * it finds into C# Vixen.EventArgs and raises a .NET event
		 * which can be handled in the C# application.
		 */
		protected void EventLoop()
		{
			_stopevents = false;
			if ((_world == null) || (_scene == null))
				return;
			if ((_world.FileName != null) && SharedWorld.DoAsyncLoad)
				_world.LoadAsync(_world.FileName, _scene);
			while (!_stopevents)
			{
				try
				{
					Event ev = _world.NextEvent();
					if (ev == null)
						break;
					string name = ev.GetName();
					EventArgs args = new VixenEventArgs(ev, RoutedVixenEvent);
					object[] list = { this, args };
					VixenEventHandler handler = new VixenEventHandler(PostVixenEvent);
					//SharedWorld.Trace("Canvas3D:Event " + name + "\n");
					Dispatcher.BeginInvoke(handler, list);
				}
				catch (Exception ex)
				{
					SharedWorld.LogError("exception in event loop " + ex.Message);
				}
			}
			_world.Stop();
		}

		protected void PostVixenEvent(object sender, VixenEventArgs args)
		{
			OnVixen(args);
			RaiseEvent(args);
			args.VixEvent.Code = 0;
		}
	}
}

