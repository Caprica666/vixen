using System;
using System.Threading;
using System.Windows;
using System.Drawing;
using System.Windows.Forms;
using System.ComponentModel;
using System.IO;


namespace Vixen
{
    /*!
     * A Windows Forms control which hosts Vixen 3D content.
     * This class handles routine of mouse and keyboard events
     * as well as starting and stopping 3D processing.
     * 
     * @see World3D Viewer3D SharedWorld
     */
	public partial class Form3D : UserControl
	{
		public Form3D()
			: base()
		{
		}

		static public int Debug = 0;
        static public bool UsePhysics = false;
		private bool StopEvents = false;

		/*!
		 * Returns an absolute path to a media file.
		 * @param filename	name of media file (may be absolute or relative).
		 *
		 * If the input pathname is absolute, it is simply returned.
		 * Otherwise, the media directory is prepended to
		 * make an absolute path.
		 * 
		 * @return absolute path of media file
		 * @see MediaDir
		 */
		public System.String GetMediaPath(System.String filename)
		{
			return Path.Combine(MediaDir, filename);
		}
		
		public System.String MediaDir;

		public System.String ContentFile;
 
        /*!
         * Enables or disables dispatching of mouse events in the 3D window to Vixen.
         * By default, mouse events in the window are converted to Vixen mouse
         * events. Setting this to false disables that routing.
         */
        public bool DispatchMouseEvents = true;

        /*!
          * The Vixen world containing the 3D scenes for this application.
          * A world may have multiple windows with 3D scenes.
          */
        public SharedWorld Viewer { get { return SharedWorld.Get(); } }

		/*!
		 * C# RoutedEventArgs from the Vixen 3D system.
		 * When the Vixen SharedWorld observes a Vixen event,
		 * it is converted to a Vixen.RoutedEvent so it can be handled
		 * with the C# event mechanism. The only event argument is
		 * the Vixen.Event object generated by the 3D environment.
		 */
		public class VixenEventArgs : EventArgs
		{
			public Event VixEvent { get; set; }

			public VixenEventArgs(Event ev) : base() { VixEvent = ev; }
			~VixenEventArgs() { }
		};

		/*!
		 * Hook to get Vixen events directed to this control.
		 * Subclass Canvas3D and add a handler for Vixen events like this:
		 * @code
		 * class MyControl : Canvas3D
		 * {
		 *      public MyControl() : base()
		 *      {
		 *          Vixen += MyControl_OnVixenEvent;
		 *      }
		 *      private void MyControl_OnEvent(Object sender, Vixen.EventArgs args)
		 *      {
		 *          Event ev = args.VixEvent;
		 *          Console.WriteLine("EVENT " + ev.GetName());
		 *      }
		 * }
		 * @endcode
		 */
		public delegate void VixenEventHandler(object sender, VixenEventArgs e);

        public event VixenEventHandler OnVixenEvent;

        /*!
         * Establishes the intial Vixen Scene for this window.
         * If a filename was provided on the command line, Vixen
         * will assume it is a 3D content file and automatically load it.
         * If you set World.DoAsyncLoad to false or if no filename is provided,
         * this asynchronous content loading is disabled and MakeScene is called.
         * The default implementation just returns null but you can
         * override this function to make a custom scene.
         */
        public virtual Scene MakeScene() { return null; }

		protected override void OnHandleCreated(System.EventArgs e)
		{
			base.OnHandleCreated(e);
			StartVixen(null);
			RunVixen();
		}

		protected override void OnHandleDestroyed(System.EventArgs e)
		{
			base.OnHandleDestroyed(e);
			StopVixen();
		}

		/*
		 * Pass resize events on to Vixen
		 */
		protected override void OnSizeChanged(EventArgs ev)
		{
			Scene scene = SharedWorld.MainScene;

			base.OnSizeChanged(ev);
			if (scene != null)
				scene.OnResize();
		}

		/*!
		 * @param world Vixen 3D world
		 * Initializes the Vixen 3D environment for the given world.
		 * If you do not provide an initial world, one is created for you.
		 * This function does not start 3D display - RunVixen does that.
		 * The world can only be initialized once - subsequent calls do nothing.
		 *
		 * @return -> Vixen SharedWorld or null if initialization failed
		 */
		static public SharedWorld StartVixen(SharedWorld world)
		{
			if (world == null)
				world = new Viewer3D();
			if ((world == null) || !world.OnInit())
			{
				LogError("cannot initialize Vixen");
				return null;
			}
			world.MakeLock();
            if (UsePhysics)
                Physics.Startup();
			return world;
		}

        /*!
         * Start up Vixen 3D display and event processing.
         * This function should not be called until the
         * underlying Window has been created and the
         * OS window handle is available. Vixen will display
         * the 3D content in this window.
         */
        public virtual bool RunVixen()
		{
			SharedWorld	world = SharedWorld.Get();
			IntPtr		windowHandle = Handle;
			Scene		scene = null;

			try
			{
				if (windowHandle == null)
				{
					LogError("Cannot get window handle for parent window");
					return false;
				}
				if ((world != null) && world.IsRunning())
					return false;
				//world.SetDebugLevel(1);
				world.Run((uint)windowHandle);
			}
			catch (Exception ex)
			{
				LogError("exception starting 3D  " + ex.Message);
			}
			if (world.IsRunning())
			{
				ThreadStart eventloop = new ThreadStart(EventLoop);
				Thread thread = new Thread(eventloop);
				bool loadasync = World.DoAsyncLoad;

				if (MediaDir != null)
					world.SetMediaDir(MediaDir);
				if (ContentFile != null)
					world.FileName = GetMediaPath(ContentFile);
				else
					loadasync = false;
				thread.Start();
				if (!loadasync)
					try
					{
						scene = MakeScene();
						if (scene != null)
							world.SetScene(scene);
					}
					catch (Exception ex)
					{
						SharedWorld.LogError("exception making initial scene " + ex.Message);
					}
				scene = world.GetScene();
				if (scene != null)
					scene.OnResize();
                return true;
			}
			return false;
		}

        /*!
         * Shuts down 3D processing and releases all 3D resources.
         * This routine is called automatically when the window closes.
         */
		public virtual void StopVixen()
		{
			SharedWorld world = SharedWorld.Get();
			if (world != null)
			{
				Scene scene = world.GetScene();

 				if (scene != null)
					scene.Window = 0;
				world.StopEvents();
				if (UsePhysics)
					Physics.Shutdown();
			}
		}

		/*!
		 * Override this function to handle initial scene loading
		 */
		protected virtual void OnSceneLoad(Scene scene, string url)
		{
		}

        /*!
         * Override this function to handle Vixen events.
         * If a Vixen event handler has been registered OnVixen will be called.
         */
        protected virtual void OnVixen(VixenEventArgs e)
        {
			if (OnVixenEvent != null)
				OnVixenEvent(this, e);
        }

		/*!
		 * Override this function to handle mouse events routed to Vixen.
		 */
		protected virtual void OnMouse(float x, float y, int buttons, float t)
		{
		}

 		protected override void OnMouseDown(MouseEventArgs e)
		{
			base.OnMouseDown(e);
			DispatchMouse(e);
		}

		protected override void OnMouseUp(MouseEventArgs e)
		{
			base.OnMouseUp(e);
			DispatchMouse(e);
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			base.OnMouseMove(e);
			DispatchMouse(e);
		}

		/*!
		  * Routes a mouse event from this window to Vixen.
		  * Any Vixen objects which observe Event.MOUSE will get these events.
		  * If DispatchMouseEvents is false, this functionality is disabled.
		  * @see DispatchMouseEvents
		  */
		private void DispatchMouse(MouseEventArgs e)
		{
			int buttons = 0;
			Keys modifiers = Control.ModifierKeys;
			SharedWorld world = SharedWorld.Get();
			Scene scene = SharedWorld.MainScene;

			if ((scene == null) || (world == null) || !world.IsRunning())
				return;
            if (!DispatchMouseEvents)
                return;
			if ((e.Button & MouseButtons.Left) != 0)
				buttons |= MouseEvent.LEFT;
			if ((e.Button & MouseButtons.Right) != 0)
				buttons |= MouseEvent.RIGHT;
			if ((e.Button & MouseButtons.Middle) != 0)
				buttons |= MouseEvent.MIDDLE;
			if ((modifiers & Keys.Control) != 0)
				buttons |= MouseEvent.CONTROL;
			if ((modifiers & Keys.Shift) != 0)
				buttons |= MouseEvent.SHIFT;
			world.OnMouse(e.X, e.Y, buttons, 0);
			OnMouse((float) e.X, (float) e.Y, buttons, 0);
		}

		/*!
		 * Events are moved from the Vixen SharedWorld to the C#
		 * application through a shared event queue. Events
		 * observed and handled by the Vixen SharedWorld object
		 * are put into a queue. The Canvas3D class maintains a separate
		 * thread which waits on this queue and converts any Vixen Events
		 * it finds into C# Vixen.EventArgs and raises a .NET event
		 * which can be handled in the C# application.
		 */
		protected void EventLoop()
		{
			SharedWorld world = SharedWorld.Get();
			StopEvents = false;

			if (world.FileName != null)
				world.LoadAsync(world.FileName, world.GetScene());
			while (!StopEvents && (SharedWorld.Get() != null))
			{
				try
				{
					Event ev = SharedWorld.Get().NextEvent();
					if (ev == null)
						break;
					if (ev.GetType() == typeof(TrackEvent))
						if (ev.Code != Event.TRACK)
							Console.Write("ERROR: TrackEvent has bad opcode");
					string		name = ev.GetName();
					EventArgs	args = new VixenEventArgs(ev);
					object[]	list = { this, args };
					VixenEventHandler handler = new VixenEventHandler(PostVixenEvent);
					Trace("Canvas3D:Event " + name + "\n");
					Invoke(handler, list);
				}
				catch (Exception ex)
				{
					LogError("exception in event loop " + ex.Message);
				}
			}
			if (SharedWorld.Get() != null)
				SharedWorld.Get().Stop();
		}

		protected void PostVixenEvent(object sender, VixenEventArgs args)
		{
			OnVixen(args);
			args.VixEvent.Code = 0;
		}

		/*!
		 * Logs an error message to the error output stream.
		 * By default, this is the console.
		 * A terminating newline is added.
		 */
		static public void LogError(System.String s)
		{
			Console.WriteLine("ERROR: " + s);
		}

		/*!
		 * Prints a message to the error output stream.
		 * By default, this is the console.
		 * A terminating newline is NOT added.
		 */
		static public void Trace(System.String s)
		{
			if (Debug > 0)
				Console.Write(s);
		}

	}
}
