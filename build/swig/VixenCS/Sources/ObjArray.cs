/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace Vixen {

using System;
using System.Runtime.InteropServices;

public class ObjArray : SharedObjArray, System.Collections.Generic.IList< ObjRef >, System.Collections.Specialized.INotifyCollectionChanged {
  private HandleRef swigCPtr;

  internal ObjArray(IntPtr cPtr, bool cMemoryOwn) : base(VixenLibPINVOKE.ObjArray_SWIGUpcast(cPtr), cMemoryOwn) {
    swigCPtr = new HandleRef(this, cPtr);
  }

  internal static HandleRef getCPtr(ObjArray obj) {
    return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
  }

  ~ObjArray() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          VixenLibPINVOKE.delete_ObjArray(swigCPtr);
        }
        swigCPtr = new HandleRef(null, IntPtr.Zero);
      }
      GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

	public ObjArray(System.Collections.ICollection c) : this()
	{
		if (c == null)
			throw new ArgumentNullException("c");
		foreach (ObjRef element in c)
			this.Append(element);
	}

    protected void OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
        if (CollectionChanged != null)
            CollectionChanged(this, e);
    }

	public event System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged;
	public bool	IsFixedSize		{ get { return false; } }
	public bool	IsReadOnly		{ get { return false; } }
	public int	Count			{ get { return (int) GetSize(); } }
	public bool	IsSynchronized	{ get { return false; } }

	public ObjRef this[int index]
	{
		get { return getitem(index); }
		set { setitem(index, value); OnCollectionChanged(new System.Collections.Specialized.NotifyCollectionChangedEventArgs(System.Collections.Specialized.NotifyCollectionChangedAction.Replace, value, index)); }
	}

	public ObjRef this[long index]
	{
		get { return getitem(index); }
		set { setitem(index, value); OnCollectionChanged(new System.Collections.Specialized.NotifyCollectionChangedEventArgs(System.Collections.Specialized.NotifyCollectionChangedAction.Replace, value, index)); }
	}

	public int Capacity
	{
		get { return (int) GetMaxSize(); }
		set { SetMaxSize(value); }
	}

	public void Add(ObjRef v)
	{
		Append(v);
		OnCollectionChanged(new System.Collections.Specialized.NotifyCollectionChangedEventArgs(System.Collections.Specialized.NotifyCollectionChangedAction.Add, v));
	}

	public void Clear()
	{
		Empty();
		OnCollectionChanged(new System.Collections.Specialized.NotifyCollectionChangedEventArgs(System.Collections.Specialized.NotifyCollectionChangedAction.Reset));
	}

	public void CopyFrom(ObjRef[] srcarray)
		{ CopyFrom(srcarray, 0, 0); }

	public void CopyTo(ObjRef[] dstarray)
		{ CopyTo(0, dstarray, 0, this.Count); }

	public void CopyTo(ObjRef[] dstarray, int dstindex)
		{ CopyTo(0, dstarray, dstindex, this.Count); }

	public void CopyFrom(ObjRef[] srcarray, long dstindex)
		{ CopyFrom(srcarray, 0, dstindex); }

	public void CopyTo(long srcindex, ObjRef[] dstarray, long dstindex, long count)
	{
		if (dstarray == null)
			throw new ArgumentNullException("dstarray");
		if (srcindex < 0)
			throw new ArgumentOutOfRangeException("srcindex", "Value is less than zero");
		if (dstindex < 0)
			throw new ArgumentOutOfRangeException("dstindex", "Value is less than zero");
		if (count < 0)
			throw new ArgumentOutOfRangeException("count", "Value is less than zero");
		if (dstarray.Rank > 1)
			throw new ArgumentException("Multi dimensional array.", "dstarray");
		if (dstindex + count > dstarray.Length)
			throw new ArgumentException("Number of elements to copy is too large.");
		for (int i = 0; i < count; i++)
			dstarray[dstindex + i] = getitem(srcindex + i);
	}

	public void CopyFrom(ObjRef[] srcarray, long srcindex, long dstindex)
	{
		int count;

		if (srcarray == null)
			throw new ArgumentNullException("srcarray");
		if (dstindex < 0)
			throw new ArgumentOutOfRangeException("dstindex", "Value is less than zero");
		if (srcindex < 0)
			throw new ArgumentOutOfRangeException("srcindex", "Value is less than zero");
		if (srcarray.Rank > 1)
			throw new ArgumentException("Multi dimensional array.", "srcarray");
		count = srcarray.Length;
		for (int i = 0; i < count; i++)
			setitem(dstindex + i, srcarray[srcindex + i]);
		OnCollectionChanged(new System.Collections.Specialized.NotifyCollectionChangedEventArgs(System.Collections.Specialized.NotifyCollectionChangedAction.Replace, this));
	}

	System.Collections.Generic.IList<ObjRef> ToList()
	{
		return this as System.Collections.Generic.IList<ObjRef>;
	}

	System.Collections.Generic.IEnumerator<ObjRef> System.Collections.Generic.IEnumerable<ObjRef>.GetEnumerator()
	{
		return new ObjArrayEnumerator(this);
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
	{
		return new ObjArrayEnumerator(this);
	}

	public ObjArrayEnumerator GetEnumerator()
	{
		return new ObjArrayEnumerator(this);
	}

  // Type-safe enumerator
  /// Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
  /// whenever the collection is modified. This has been done for changes in the size of the
  /// collection but not when one of the elements of the collection is modified as it is a bit
  /// tricky to detect unmanaged code that modifies the collection under our feet.
	public sealed class ObjArrayEnumerator : System.Collections.IEnumerator, System.Collections.Generic.IEnumerator<ObjRef>
	{
		private ObjArray collectionRef;
		private long currentIndex;
		private object currentObject;
		private long currentSize;

		public ObjArrayEnumerator(ObjArray collection)
		{
			collectionRef = collection;
			currentIndex = -1;
			currentObject = null;
			currentSize = collectionRef.Count;
		}

		// Type-safe iterator Current
		public ObjRef Current
		{
			get
			{
				if (currentIndex == -1)
					throw new InvalidOperationException("Enumeration not started.");
				if (currentIndex > currentSize - 1)
					throw new InvalidOperationException("Enumeration finished.");
				if (currentObject == null)
					throw new InvalidOperationException("Collection modified.");
				return (ObjRef) currentObject;
			}
		}

		// Type-unsafe IEnumerator.Current
		object System.Collections.IEnumerator.Current { get { return Current; } }

		public bool MoveNext()
		{
			int size = collectionRef.Count;
			bool moveOkay = (currentIndex+1 < size) && (size == currentSize);
			if (moveOkay)
			{
				currentIndex++;
				currentObject = collectionRef[currentIndex];
			}
			else
				currentObject = null;
		  return moveOkay;
		}

		public void Reset()
		{
			currentIndex = -1;
			currentObject = null;
			if (collectionRef.GetSize() != currentSize)
				throw new InvalidOperationException("Collection modified.");
		}

		public void Dispose()
		{
			currentIndex = -1;
			currentObject = null;
		}
		
		public void Reverse()
		{
			collectionRef.Reverse(0, (int) currentSize);
		}
	}

  public ObjArray(long size) : this(VixenLibPINVOKE.new_ObjArray__SWIG_0(size), true) {
  }

  public ObjArray() : this(VixenLibPINVOKE.new_ObjArray__SWIG_1(), true) {
  }

  public ObjArray(ObjArray src) : this(VixenLibPINVOKE.new_ObjArray__SWIG_2(ObjArray.getCPtr(src)), true) {
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  new public SharedObj GetAt(long index) 
	{
		IntPtr cPtr = VixenLibPINVOKE.ObjArray_GetAt__SWIG_0(swigCPtr, index);
		return (SharedObj)  SharedObj.MakeObject(cPtr, true);
	}


  public bool SetAt(long index, SharedObj arg1) {
    bool ret = VixenLibPINVOKE.ObjArray_SetAt(swigCPtr, index, SharedObj.getCPtr(arg1));
    return ret;
  }

  public virtual long Find(SharedObj obj) {
    long ret = VixenLibPINVOKE.ObjArray_Find(swigCPtr, SharedObj.getCPtr(obj));
    return ret;
  }

  public virtual long Append(SharedObj obj) {
    long ret = VixenLibPINVOKE.ObjArray_Append(swigCPtr, SharedObj.getCPtr(obj));
    return ret;
  }

  private ObjRef getitem(long index) {
    ObjRef ret = new ObjRef(VixenLibPINVOKE.ObjArray_getitem(swigCPtr, index), true);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private void setitem(long index, ObjRef val) {
    VixenLibPINVOKE.ObjArray_setitem(swigCPtr, index, ObjRef.getCPtr(val));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public void AddRange(SharedObjArray values) {
    VixenLibPINVOKE.ObjArray_AddRange(swigCPtr, SharedObjArray.getCPtr(values));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public ObjArray GetRange(int index, int count) 
	{
		IntPtr cPtr = VixenLibPINVOKE.ObjArray_GetRange(swigCPtr, index, count);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
		return (ObjArray)  SharedObj.MakeObject(cPtr, true);
	}


  public void Insert(int index, ObjRef x) {
    VixenLibPINVOKE.ObjArray_Insert(swigCPtr, index, ObjRef.getCPtr(x));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public void InsertRange(int index, SharedObjArray values) {
    VixenLibPINVOKE.ObjArray_InsertRange(swigCPtr, index, SharedObjArray.getCPtr(values));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public void RemoveAt(int index) {
    VixenLibPINVOKE.ObjArray_RemoveAt(swigCPtr, index);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public void RemoveElem(int index) {
    VixenLibPINVOKE.ObjArray_RemoveElem(swigCPtr, index);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public void RemoveRange(int index, int count) {
    VixenLibPINVOKE.ObjArray_RemoveRange(swigCPtr, index, count);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public static ObjArray Repeat(ObjRef value, int count) 
	{
		IntPtr cPtr = VixenLibPINVOKE.ObjArray_Repeat(ObjRef.getCPtr(value), count);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
		return (ObjArray)  SharedObj.MakeObject(cPtr, true);
	}


  public void Reverse(int index, int count) {
    VixenLibPINVOKE.ObjArray_Reverse(swigCPtr, index, count);
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public void SetRange(int index, SharedObjArray values) {
    VixenLibPINVOKE.ObjArray_SetRange(swigCPtr, index, SharedObjArray.getCPtr(values));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public bool Contains(ObjRef value) {
    bool ret = VixenLibPINVOKE.ObjArray_Contains(swigCPtr, ObjRef.getCPtr(value));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public int IndexOf(ObjRef value) {
    int ret = VixenLibPINVOKE.ObjArray_IndexOf(swigCPtr, ObjRef.getCPtr(value));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public int LastIndexOf(ObjRef value) {
    int ret = VixenLibPINVOKE.ObjArray_LastIndexOf(swigCPtr, ObjRef.getCPtr(value));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Remove(ObjRef value) {
    bool ret = VixenLibPINVOKE.ObjArray_Remove(swigCPtr, ObjRef.getCPtr(value));
    if (VixenLibPINVOKE.SWIGPendingException.Pending) throw VixenLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
