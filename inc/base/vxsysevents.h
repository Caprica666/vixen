/*!
 * @file vxsysevents.h
 * @brief Event classes for 3D communication.
 *
 * These small packets of information can be sent
 * between scene manager objects on both local and remote machines.
 * Vixen events can also be sent to Java.
 *
 * @author Nola Donato
 * @ingroup vixen
 *
 * @see vxevent.h vxmess.h
 * @see @htmlonly <A HREF="oview/vixen_events.htm">Event Summary</A> @endhtmlonly
 */

#pragma once
#undef ABSOLUTE

namespace Vixen {


/*!
 * @class LoadEvent
 * @brief Event::LOAD_SCENE, Event::LOAD_IMAGE and Event::LOAD_TEXT
 * describe file loading events for scene, image and text files.
 *
 * They are generated by the file loader after a file has been
 * completely read and translated into scene manager objects.
 *
 * @ingroup vixen
 * @see SceneEvent FileLoader SceneLoader
 */
class LoadEvent : public Event
{
public:
	LoadEvent(int code = LOAD_SCENE, SharedObj* sender = NULL)
		: Event(code, sizeof(Core::String), sender) {  }
	LoadEvent(int code, int size, SharedObj* sender = NULL)
		: Event(code, size, sender) {  }
	LoadEvent(const Event& src);
	virtual Event&	operator=(const Event&);

	Core::String	FileName;	//!< Fully qualified pathname of file or URL.
};

/*!
 * @class LoadSceneEvent
 * @brief Event::LOAD_SCENE
 * describe text string load
 *
 * They are generated by the file loader as a text file is loaded.
 *
 * @ingroup vixen
 * @see FileLoader LoadEvent
 */
class LoadSceneEvent : public LoadEvent
{
public:
	LoadSceneEvent(int code = LOAD_SCENE, SharedObj* sender = NULL)
		: LoadEvent(code, sizeof(ObjRef) + sizeof(Core::String), sender) { }
	LoadSceneEvent(const Event& src);
	virtual Event&	operator=(const Event&);

	ObjRef		Object;		//!< Object which was loaded. Scene for .vix files, Texture for bitmaps.
};

/*!
 * @class LoadTextEvent
 * @brief Event::LOAD_TEXT
 * describe text string load
 *
 * They are generated by the file loader as a text file is loaded.
 *
 * @ingroup vixen
 * @see FileLoader LoadEvent
 */
class LoadTextEvent : public LoadEvent
{
public:
	LoadTextEvent(int code = LOAD_TEXT, SharedObj* sender = NULL)
		: LoadEvent(code, sizeof(int) + 2 * sizeof(Core::String), sender) { SequenceID = 0; }
	LoadTextEvent(const Event& src);
	virtual Event&	operator=(const Event&);

	Core::String	Text;		//!< text string
	int				SequenceID;	//!< pointer to data
};

/*!
 * @class LoadDataEvent
 * @brief Event::LOAD_DATA
 * describe binary data load
 *
 * They are generated by the file loader after a binary file has been
 * completely read and accumulated into memory.
 *
 * @ingroup vixen
 * @see SceneEvent FileLoader SceneLoader
 */
class LoadDataEvent : public LoadEvent
{
public:
	LoadDataEvent(int code = LOAD_DATA, SharedObj* sender = NULL)
		: LoadEvent(code, 2 * sizeof(intptr) + sizeof(Core::String), sender) { Data = 0; Length = 0; }
	LoadDataEvent(const Event& src);
	virtual Event&	operator=(const Event&);

	intptr		Length;		//!< byte length of memory
	intptr		Data;		//!< pointer to data
};

/*!
 * @class MouseEvent
 * @brief Event::MOUSE describes mouse motion from an external device.
 *
 * Usually, these events are generated by World
 * in response to mouse motion. Mouse buttons are translated
 * to zero or more of these codes:
 * 
 * - MouseEvent::LEFT
 * - MouseEvent::RIGHT
 * - MouseEvent::MIDDLE
 * - MouseEvent::SHIFT
 * - MouseEvent::CONTROL
 *
 * @ingroup vixen
 * @see KeyEvent NavigateEvent NavInputEvent
 */
class MouseEvent : public Event
{
public:
	MouseEvent()	: Event(Event::MOUSE, sizeof(Vec2) + sizeof(int32)) {}
	MouseEvent(const Event& src);
	Event&	operator=(const Event&);


	/*!
	 * @brief Describes mouse input modifier flags.
	 *
	 * @see MouseEvent
	 */
	enum
	{
		LEFT = 1,		//!< left button pressed
		RIGHT = 2,		//!< right button pressed
		MIDDLE = 16,	//!< middle button pressed
		SHIFT = 4,		//!< shift key pressed
		CONTROL = 8,	//!< control key pressed
		DOUBLE = 16,	//!< double click
	};
	Vec2	MousePos;	//!< 2D mouse position
	int32	MouseFlags;	//!< mouse buttons code
};

/*!
 * @class NavInputEvent
 * @brief Event::NAVINPUT describes 3D motion in a device-independent way.
 *
 * Instead of pixel positions, the X, Y and Z axes are defined from
 * +1 to -1 so that motion is independent of display size.
 * JoyStick generates these events in response to joystick movement.
 *
 * @ingroup vixen
 * @see MouseEvent NavigateEvent JoyStick
 */
struct NavInputEvent : public Event
{
	NavInputEvent();
	NavInputEvent(const Event& src);
	Event&	operator=(const Event&);

	Vec3	Pos;		//!< 3D degress of freedom movement
	int32	Buttons;	//!< device buttons
	int32	DeviceID;	//!< number indicating a device
};

/*!
 * @class KeyEvent
 * @brief Event::KEY describes a keypress.
 *
 * Usually, these events are generated by World
 * in response to keybaord input. If World::RawInput
 * is  true, keyboard events are all in upper case and include
 * control characters - no translation is performed.
 * Otherwise, some virtual key codes are translated.
 *
 * Modifier keys are stored in terms of these bit flags:
 *	- ALT		alt key pressed
 *	- UP		key is up
 *	- SHIFT		shift key pressed
 *	- CONTROL	control key pressed
 *	- RETURN	return key pressed
 *	- REPEAT	key is repeated
 *
 * @ingroup vixen
 * @see Event MouseEvent
 */
class KeyEvent : public Event
{
public:
	KeyEvent() : Event(Event::KEY, 2 * sizeof(int32)) {}
	KeyEvent(const Event& src);
	Event&	operator=(const Event&);

	int32	KeyCode;	//!< key code
	int32	KeyFlags;	//!< modifier key bit flags
	
	/*!
	 *
	 * @brief non-ASCII character codes passed in the KeyEvent
	 * to keyboard handling engines.
	 *
	 * In raw mode, these characters are
	 * transmitted with their keycodes preserved. In thise case, some of
	 * these virtual characters could be represented as multiple
	 * KeyEvent objects.
	 *
	 * When not in raw mode, the scene manager defines single values to represent the
	 * following virtual key codes. To avoid conflict with ANSI values,
	 * these are 0x100 more than their Windows virtual key codes.
	 *
	 * T+
	 *		K_ESCAPE	0x11B
	 *		K_END		0x123
	 *		K_HOME		0x124
	 *		K_LEFT		0x125
	 *		K_UP		0x126
	 *		K_RIGHT		0x127
	 *		K_DOWN		0x128
	 *		K_INSERT	0x12D
	 *		K_DELETE	0x12E
	 *		K_F1		0x170
	 *		K_F2		0x171
	 *		K_F3		0x172
	 *		K_F4		0x173
	 *		K_F5		0x174
	 *		K_F6		0x175
	 *		K_F7		0x176
	 *		K_F8		0x177
	 *		K_F9		0x178
	 *		K_F10		0x179
	 * T-
	 */
	enum
	{
		K_ESCAPE = (VK_ESCAPE+0x100),
		K_END  = (VK_END+0x100),
		K_HOME = (VK_HOME+0x100),
		K_LEFT  = (VK_LEFT+0x100),
		K_UP = (VK_UP+0x100),
		K_RIGHT = (VK_RIGHT+0x100),
		K_DOWN = (VK_DOWN+0x100),
		K_INSERT = (VK_INSERT+0x100),
		K_DELETE = (VK_DELETE+0x100),
		K_PAGEUP = (VK_PRIOR+0x100),
		K_PAGEDOWN = (VK_NEXT+0x100),
		K_F1 = (VK_F1+0x100),
		K_F2 = (VK_F2+0x100),
		K_F3 = (VK_F3+0x100),
		K_F4 = (VK_F4+0x100),
		K_F5 = (VK_F5+0x100),
		K_F6 = (VK_F6+0x100),
		K_F7 = (VK_F7+0x100),
		K_F8 = (VK_F8+0x100),
		K_F9 = (VK_F9+0x100),
		K_F10 = (VK_F10+0x100),
		K_F11 = (VK_F11+0x100),
		K_F12 = (VK_F12+0x100),
		K_ADD = (VK_ADD+0x100),
		K_SUBTRACT = (VK_SUBTRACT+0x100),
		K_CONTROL = (VK_CONTROL+0x100)
	};

	/*!
	 * @brief key modifier flags for a keyboard event.
	 */
	enum
	{
		ALT = 0x2000,		//!< alt key pressed
		UP = 0x8000,		//!< key is up
		REPEAT = 0x4000,	//!< key is repeated
		MASK = 0xE000
	};
};



/*!
 * @class NavigateEvent
 * @brief Event::NAVIGATE is a common navigation event that can be generated by
 * mouse, keyboard, joystick or other input devices.
 *
 * Supports a set of commands allowing navigation with a scene.
 * There are commands to look up, down, right or left by rotating
 * a specified angle about the X or Y axes. The commands to
 * move specify the distance with respect to a unit cube which
 * can be scaled to the desired viewport.
 *
 * A navigation event need not specify all types of movement possible.
 * The  Flags member gives information about which other members
 * are valid and how they are interpreted.
 *
 * @ingroup vixen
 * @see MouseEvent NavInputEvent Flyer Navigator
 */
struct NavigateEvent : public Event
{
	NavigateEvent();
	NavigateEvent(const NavigateEvent& src);
	Event&	operator=(const Event&);

	int32	Flags;	//!< navigation flags indicating what data is present
	Vec3	Pos;	//!< distance to move in X,Y,Z
	Quat	Rot;	//!< turn angle/axis rotation
	Quat	Look;	//!< look angle/axis orienation

	/*!
	 * @brief the contents of a navigation event.
	 */
	enum
	{
		CENTER = 0,
		POSITION = 1,		//!< set if position supplied in Pos
		ROTATION = 2,		//!< set if turn rotation supplied in Rot
		LOOK = 4,			//!< set if look rotation supplied in Rot
		SCALE = 8,			//!< set if scale supplied in Scale
		LOCAL_POS = 16,		//!< set if local position supplied in Pos
		ABSOLUTE = 32,		//!< set if motion is absolute
		XROTATION = 64,		//!< set if rotation is about X axis
		YROTATION = 128,	//!< set if rotation is about Y axis
		ZROTATION = 256,	//!< set if rotation is about Z axis
		EVENT_PENDING = 512,//!< indicates event is pending to Transformer
	};

};

/*!
 * @class SceneEvent
 * @brief Event::SCENE_CHANGE and Event::ATTACH_SCENE indicate changes to the display scene.
 *
 * Setting the scene will replace the current display scene
 * completely while attaching just indicates a remote scene has finished
 * downloading. They are generated by the application in response to
 * receiving a scene load event or from external references.
 *
 * @ingroup vixen
 * @see LoadEvent World3D::SetScene ExtModel
 */
typedef Ref<Scene> SceneRef;	// this is for SWIG
class SceneEvent : public Event
{
public:
	SceneEvent(int code = SCENE_CHANGE, const Scene* scene = NULL, const SharedObj* sender = NULL)
		: Event(code, sizeof(ObjRef) + sizeof(intptr) + sizeof(Core::String), sender) { Target = (Scene*) scene, WindowHandle = 0; }
	SceneEvent(const Event& src);
	~SceneEvent();
	Event&		operator=(const Event&);

	SceneRef	Target;			//!< New scene to use for display.
	intptr		WindowHandle;	//!< Handle to display window.
};

/*!
 * @class ErrorEvent
 * @brief Event::ERROR represents an error message
 *
 * It is used to implement asychronous error reporting
 * in a distributed environment.
 *
 * @ingroup vixen
 */
class ErrorEvent : public Event
{
public:
	ErrorEvent(const SharedObj* sender = NULL)
		: Event(ERROR, 2 * sizeof(int32) + sizeof(Core::String), sender) { ErrLevel = 0; ErrCode = 0; }
	ErrorEvent(const Event& src);
	Event&		operator=(const Event&);

	int32			ErrCode;	//!< error code
	int32			ErrLevel;	//!< severity level
	Core::String	ErrString;	//!< error message string
};

/*!
 * @class FrameEvent
 * @brief Event::SET_TIME indicates the start of a frame.
 *
 * It is typically used to synchronize simulations across a distributed network.
 *
 * @ingroup vixen
 * @see Scene::GetTime World::GetTime
 */
class FrameEvent : public Event
{
public:
	FrameEvent(const SharedObj* sender = NULL)
		: Event(SET_TIME, sizeof(int32), sender) { Frame = 0; }
	FrameEvent(const Event& src);
	Event&		operator=(const Event&);

	int32		Frame;	//!< Frame number.
};

/*!
 * @class TriggerEvent
 * @brief Event::LEAVE and Event::ENTER are proximity triggers
 * that indicate when an object enters or leaves a trigger zone.
 *
 * Trigger events are usually generated by a trigger engine when
 * it determines a scene object has touched the trigger collision
 * geometry and again when the object is completely outside the
 * geometry again. These events are intended to be useful for
 * other collision detection methods.
 *
 * @ingroup vixen
 * @see Trigger Animator
 */
struct TriggerEvent : public Event
{
	TriggerEvent(int code = ENTER);
	TriggerEvent(const TriggerEvent& src);
	Event&	operator=(const Event&);
	ObjRef	Target;		//!< Scene object associated with trigger or first object in collision.
	ObjRef	Collider;	//!< Scene object entering/leaving collision area or second object in collision.
/*!
 * Point of collision. Usually, this is the center of the collider in
 * the coordinate space of the trigger geometry.
 */
	Vec3	CollidePos;
};

/*!
 * @class ConnectEvent
 * @brief Event::CONNECT indicates connection by a remote client.
 *
 * It is used when a scene is distributed across a network to tell
 * the server that a new client has connected.
 * @ingroup vixen
 */
struct ConnectEvent : public Event
{
	ConnectEvent(int code = CONNECT);
	ConnectEvent(const ConnectEvent& src);
	Event&	operator=(const Event&);

	int32		ConnectID;		// ID of connection
};

/*!
 * @class TriHitEvent
 * @brief Event::TRI_HIT signals a triangle is hit (or picked)
 *
 * It is used to describe a ray / triangle intersection
 * and is generated by the ray picker when mesh picking is enabled.
 *
 * @ingroup vixen
 * @see TriMesh::Hit RayPicker
 */
typedef Ref<Mesh> MeshRef;	// this is for SWIG

class TriHitEvent : public Event
{
public:
	TriHitEvent(int code = TRI_HIT);
	TriHitEvent(const TriHitEvent& src);
	Event&	operator=(const Event&);

	MeshRef		Target;
	Vec3		Intersect;
	float		Distance;
	int64		PrimIndex;
	int64		TriIndex;
};

/*!
 * @class PickEvent
 * @brief Event::PICK signals one or more objects have been picked
 * @brief Event::NOPICK signals nothing has been picked
 * @brief Event::SELECT signals an object is selected and should be hilited
 * @brief Event::DESELECT signals an object is deselected and should no longer be hilited
 *
 * It is used to describe a selection or pick operation. A selected object is
 * hilighted in some way - the default hilighting is to change it's associated Appearance.
 * Events are provided so the application can perform custom selection hilighting.
 * An object is considered to be a pick when the user actually chooses it. For a
 * mouse-based picker, this is on mouse up. For a gesture-based picker,  the
 * object under your hand will be hilighted but not picked until you do a certain gesture.
 *
 * @ingroup vixen
 * @see TriMesh::Hit RayPicker
 */
class PickEvent : public Event
{
public:
	PickEvent(int code = PICK, SharedObj* sender = NULL);
	PickEvent(const Event& src);
	Event&	operator=(const Event&);

	ObjRef	Target;	//! nearest object or selected object
};

/*!
 * @class TrackEvent
 * @brief Event::TRACK indicates a body or gesture tracker event.
 *
 * The events currently emitted for tracking are:
 * @code
 *		NEW_USER	indicates a new user has entered the scene
 *		LOST_USER	indicates an existing user has left the scene
 *		START_TRACK	successful calibration for a user, tracking has begun
 *		BAD_CALIB	calibration failed for a user and tracking failed
 *		POSE_FOUND	user pose detected, pose name provided in event
 *		USER_MOVE	user moved, event contains Skeleton body part index, position and rotation
 * @endcode
 *
 * This event type is used by the Kinect body tracker to communicate state changes
 * from it's callbacks.
 *
 * @ingroup vixen
 */
struct TrackEvent : public Event
{
public:
	TrackEvent(int code = TRACK, const SharedObj* sender = NULL);
	TrackEvent(int type, int userid, const SharedObj* sender = NULL);
	TrackEvent(const Event& src);
	Event&	operator=(const Event&);

	enum
	{
		UNKNOWN = 0,
		NEW_USER = 1,		//! new user detected
		LOST_USER,			//! user lost
		START_BODY_TRACK,	//! skeleton tracking has started
		STOP_BODY_TRACK,	//! skeleton tracking has stopped
		PAUSE_BODY_TRACK,	//! body tracking has paused
		USER_MOVE,			//! some part of the user moved
		INIT_DONE,			//! initialization complete
		USER_TURN,			//! user turned away or towards the sensor
	};

	int32			Type;		//! type of Kinect occurrence
	int32			UserID;		//! ID of user
	int32			PartIndex;	//! Skeleton index of body part
	Vec3			Position;	//! world position of body part
	Quat			Rotation;	//! world rotation of body part
	Core::String	PartName;	//! name of pose, gesture, body part
};

} // end vixen