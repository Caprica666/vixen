/*!
 * @file vxworld3d.h
 *
 * @brief Defines a singleton container for a distributed 3D world.
 *
 * @author Nola Donato
 * @ingroup vixen
 * @see vxworld.h vxscene.h
 */
#pragma once

namespace Vixen {

class Scene;
class SceneLoader;

/*!
 * @class World3D
 * @brief Global class that controls content loading and event
 * dispatch for one or more 3D scenes.
 *
 * This base class encapsulates the platform-independent functionality to handle
 * file loading, event processing and task management. Vixen supports several
 * operating systems and window managers by subclassing World to add OS or
 * framework-dependent features.
 *
 * Each process running Vixen has only one world that acts as an event dispatcher.
 * Operating system input from the mouse, keyboard or other devices is directed
 * toward specific \b engines in the simulation tree of a \b scene in the world.
 * Window events like repaint and resize are communicated to the underlying
 * 3D display platform.
 *
 * @image html app_structure.png
 *
 * In some environments, such as with a Vixen browser plugin, there is
 * one scene per world. Separate Vixen windows on a web page
 * represent different instances of Vixen. In the Windows desktop environment,
 * A world may have more than one scene associated with it.
 * Each scene must run in a separate window and is identified to
 * the world by the window handle it belongs to.
 *
 * <B>Content Loading</B>
 *
 * World handles the loading of initial scene content and can be requested
 * to asynchronously load image, scene or text files. It maintains a pool
 * of I/O handling threads that can obtain content from local disk files,
 * the Internet or another machine on a local network.
 *
 * <B>Distributed Processing</B>
 *
 * In the distributed environment, such as the display wall or the internet,
 * one scene is distributed across multiple processors, each running a
 * separate instance of Vixen and communicating changes via a network.
 * In this situation, the world maintains a set of communication
 * \b messengers that manage object updates on the remote processors.
 * @image html messenger.jpg
 *
 * <B>Initialization and Shutdown</B>
 *
 * The world controls the startup and shutdown of Vixen. The default
 * system behavior when multi-threaded is to start several threads to
 * handle asynchronous loading of content and images. Until a window
 * handle is provided (see World::SetWindow), no graphics resources are
 * used. When multi-threading, all display processing is handled by the
 * rendering threads - including engine execution, event processing and
 * some image management. A world shuts down when its main window
 * is released or when all of the 3D scene windows have been closed. Upon
 * shutdown, first rendering threads are stopped and then file load threads.
 *
 * Arguments from the command line or shortcut can be accessed
 * from World. Vixen uses the \b UNIX convention that the 0th argument
 * is the name of the executable. Typically, the first argument is
 * the name of a .Vixen file which is opened and displayed at startup.
 * To suppress or change this default behavior, you can override
 * World::MakeScene to build the initial scene.
 *
 * <B>Windows Platform Specifics</B>
 *
 * If you are using MFC, your application class should derive from
 * \b VXFCApp and your Vixen world from \b VXFCWorld.
 * The companion \b VXView class, derived from \b CView,
 * displays a 3D scene in the window associated with the view.
 * Mouse events from this view are automatically directed to the
 * World mouse handler. You can generate a single-document application with
 * AppWizard and substitute VXView for CView, and add World.
 *
 * If you are not using MFC, your application controls WinMain,
 * the message pump and the display.  subclasses \b WinWorld subclassesw
 * \b World to provides a default WinMain and WndProc which
 * you can use to integrate Vixen keyboard and mouse handling
 * into a normal Windows application. Mouse, keyboard a file loading
 * events are generated by the application and given to the
 * messenger. You can ask the messenger to dispatch particular types of events
 * to specific engines in your world.
 *
 * Vixen also works in console applications, although it cannot
 * display anything. You still need to instantiate a
 * World object to initialize Vixen but you need not override
 * any methods. Some Vixen art tools are console applications.
 *
 * @see FileLoader Scene WinWorld VXMFCWorld World
 */
class World3D : public World
{
public:
	VX_DECLARE_CLASS(World3D);
	World3D();

//! Returns the only world.
	static World3D*	Get()	{ return (World3D*) s_OnlyOne; }

//! Returns the scene for the given window.
	Scene*			GetScene(Window =  Window(NULL)) const;

//! Establish the display scene for a given window.
	virtual void	SetScene(Scene*, Window = Window(NULL));

//! Return file loader used to load content.
	SceneLoader*	GetLoader() const	{ return (SceneLoader*) (FileLoader*) m_LoadQueue; }

// World Overrides
	virtual bool	Run(Window);
	virtual void	Stop();
	virtual	Event*	MakeEvent(int code);
	virtual bool	OnInit();
	virtual void	OnExit();

 //	SharedObj Overrides
	virtual bool	OnEvent(Event*);
	virtual bool	Do(Messenger& s, int opcode);

//	Internal
	virtual	void	AddScene(Scene* scene, Window win);
	virtual	bool	KillScene(Scene* scene);

//	Public Data
	bool			RawInput;			//!< \b true for raw keyboard input
	Box2			WinRect;			//!< initial window rectangle

	enum Opcode
	{
		WORLD3D_SetScene = World::WORLD_NextOp,
		WORLD3D_NextOp = World::WORLD_NextOp + 10
	};

protected:
	virtual	Scene*	MakeScene(const TCHAR* = NULL);
	virtual void	AttachScene(Scene*);
	virtual	Scene*	NewScene(Window = Window(NULL), Scene* = NULL);
	bool			MergeLoaderDict(Scene* scene);

	RefArray<Scene>	m_Scenes;				// scenes for this world
};

/*!
 * @class SceneLoader
 * @brief Asynchronously loads scene files.
 *
 * The scene loader manages a pool of worker threads which asynchronously
 * load scene files and their associated images and text.
 *
 * @ingroup vixenint
 * @see World::LoadAsync Texture::Load FileLoader
 */
class SceneLoader : public FileLoader
{
public:
	VX_DECLARE_CLASS(SceneLoader);
	SceneLoader() : FileLoader() { m_LastDict = NULL; }
//! Return the dictionary for the given scene.
	NameTable*	GetSceneDict(const TCHAR* scenename) const;
//!	Set the dictionary for the given scene.
	void		SetSceneDict(const TCHAR* scenename, NameTable* dict);
//! Find a single object by name.
	SharedObj*	Find(const TCHAR* objname, const TCHAR* dictname = NULL);
//! Find a set of objects using a wildcard name search.
	Vixen::ObjArray*	FindAll(const TCHAR* objname, const TCHAR* dictname = NULL);
//! Unload a file, freeing any in-memory representation.
	void		Unload(const TCHAR* filename);
//!	Read a file and send an event to the observer.
	static bool	ReadScene(const TCHAR* fname, Core::Stream* instream, LoadEvent* event);
	void		Kill();

protected:	
	NameTable*	m_LastDict;			// dictionary of last file loaded
};

} // end Vixen