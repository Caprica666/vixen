#pragma once

#include "metypes.h"
#include "meshade.h"

#define ME_NOUVS	-1	// no UV coordinates
#define ME_GENUVS	-2	// UVS generated by exporter


/*!
 * @class meConvProj
 * @brief Converter for projection nodes
 *
 * Converts a Maya projection node which links a 3D texture projection matrix
 * to a texture image. This class exists primarily to preserve the linkage
 * between the texture being projected and the 3D texture placement.
 * The Maya projection node links these in the case of environment
 * mapping. (In the normal 3D texture case, the UV placement is linked
 * directly to the texture).
 *
 * @see meConvTex meConvUV meConvUV3
 */
class meConvProj : public meConvShader
{
public:
    meConvProj(MObject& mayaobj) : meConvShader(mayaobj) { }

    SharedObj*	Make();
    int		Link(meConvObj* convparent = NULL);

protected:
    MObject m_TexImage;
};


/*!
 * @class meConvUV
 * @brief Converter for UV mapping
 *
 * Encapsulates the Maya 2D UV mappping information to be
 * applied to UV sets for mesh geometry.
 *
 * Texture coordinates in Maya are stored without any UV mapping applied.
 * Static 2D UV mapping is detected and applied by the exporter to the Maya
 * texcoords before they are stored in Vixen format.
 *
 * @see meConvTex meConvMesh::LinkUVMappers
 */
class meConvUV : public meConvShader
{
public:
    meConvUV(MObject& uvobj);

    SharedObj*	Make();
    int		Convert(meConvObj* = NULL);
    int		Link(meConvObj* convparent = NULL);
    virtual bool MapUV(Vec2* outuv, Vec3* loc, Vec3* ctr);
    virtual bool MapUV(Vec2* uvs, int n);

    bool	NoTexCoords;	//!< UV coordinates generated at run time
    bool	MakeTexCoords;	//!< UV coordinates generated by exporter

protected:
    virtual void map(float inU, float inV, float& outU, float& outV);
    float	 mapV(float inU, float inV, bool& inside);
    float	 mapU(float inU, float inV, bool& inside);

    bool  HasMapper;
    float RotateFrame, RotateUV;
    float CoverageU, CoverageV;
    float TranslateU, TranslateV;
    float RepeatU, RepeatV;
    float OffsetU, OffsetV;
    float WrapU, WrapV;
    float Stagger;
    float Mirror;
};

/*!
 * @class meConvUV3
 * @brief Converter for 3D UV mapping
 *
 * Encapsulates the Maya 3D UV mappping information to be
 * applied to UV sets for mesh geometry. Used mostly with
 * procedural textures. The 3D texture projection matrix from
 * Maya is used as the Vixen texture matrix in the geostate.
 * If the texture associated with the UV mapping is used as a
 * reflection map, then Vixen is requested to automatically
 * generate the texture coordinates using a spherical texgen.
 *
 * @see meConvMesh::LinkUVMappers meConvUV meConvProj
 */
class meConvUV3 : public meConvUV
{
public:
    meConvUV3(MObject& uvobj);
    SharedObj*	Make();
    int		Convert(meConvObj* = NULL);
    int		Link(meConvObj* convparent = NULL);
    void	UpdateState(meConvState* state, int texindex);
    bool	MapUV(Vec2* outuv, Vec3* loc, Vec3* ctr);

    int		UVGen;
protected:
    void map(float inU, float inV, float& outU, float& outV);

    Matrix	UVMatrix;
};

